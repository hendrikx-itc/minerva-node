#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Minerva Node command line script
"""
import sys
import argparse
import logging
import signal
import time
from time import sleep
import threading
import json
import traceback

import psycopg2
from psycopg2._psycopg import OperationalError

from minerva_node.plugins import load_plugins
from minerva_node.error import NodeError, JobError
from minerva_node import Job, MinervaContext, log, version
from minerva_node.config import load_config, ConfigError
from minerva_node.pika_consumer import PikaConsumer


SIGNAL_MAP = {
    signal.SIGHUP: "SIGHUP",
    signal.SIGKILL: "SIGKILL",
    signal.SIGTERM: "SIGTERM",
    signal.SIGINT: "SIGINT",
    signal.SIGUSR1: "SIGUSR1"
}

NOJOB_TIMEOUT = 1
DB_CONNECT_TIMEOUT = 1


class StartupError(Exception):
    pass


def main():
    """
    Script entry point
    """
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-c", "--config-file",
        default="/etc/minerva/node-rabbitmq.conf",
        help="the path to the config file"
    )

    parser.add_argument(
        "-v", "--version", action="version",
        version="%(prog)s {}".format(version.__version__)
    )

    args = parser.parse_args()

    try:
        config = load_config(args.config_file)
    except ConfigError as exc:
        print("error loading configuration: {}".format(exc))
        return 1

    rabbitmq_config = config['rabbitmq']

    consumer = PikaConsumer(
        rabbitmq_config['url'],
        rabbitmq_config['queue'],
        rabbitmq_config['routing_key'],
        logging.getLogger('pika-consumer')
    )

    stop_event = threading.Event()

    def stop_node(signum, frame):
        log_signal(signum, frame)
        consumer.stop()
        stop_event.set()

    signal.signal(signal.SIGTERM, stop_node)
    signal.signal(signal.SIGINT, stop_node)
    signal.signal(signal.SIGHUP, stop_node)

    log.setup_logging(config["log_level"])

    def connect():
        return psycopg2.connect('')

    conn = None

    while not stop_event.is_set():
        try:
            conn = connect()
        except OperationalError as e:
            logging.error(
                "could not connect to database, waiting {} seconds".format(
                    DB_CONNECT_TIMEOUT
                )
            )
            time.sleep(DB_CONNECT_TIMEOUT)
        else:
            break

    if conn:
        minerva_context = MinervaContext(conn)

        node = setup_node(stop_event, minerva_context, consumer)

        node.start()

        logging.info("started")

        while node.is_alive():
            sleep(1)

    logging.info("stopped")


def log_signal(signum, _frame):
    logging.info("received {0!s} signal".format(
        SIGNAL_MAP.get(signum, signum)))


def setup_node(stop_event, minerva_context, queue_conn):
    plugins = load_plugins()

    for plugin in plugins:
        logging.info("loaded plugin '{}'".format(plugin.name))

    plugin_dict = {
        p.name: p(minerva_context)
        for p in plugins
    }

    def on_message(job_message):
        try:
            job = json.loads(job_message)
        except ValueError:
            logging.error("invalid job description: {}".format(job_message))
        else:
            process_job(minerva_context.conn, create_job(plugin_dict, job))

    queue_conn.handle_message = on_message

    return threading.Thread(target=queue_conn.run, name="Node")


def process_job(conn, job):
    try:
        job.execute()
    except JobError as exc:
        safe_rollback(conn)
        logging.error(str(exc))
    except NodeError as exc:
        safe_rollback(conn)
        logging.error(str(exc))
    except Exception as exc:
        safe_rollback(conn)
        message = traceback.format_exc()
        logging.error(message)
    else:
        logging.info("finished job {}".format(job))


def safe_rollback(conn):
    conn.rollback()


def safe_commit(conn):
    conn.commit()


def create_job(plugin_dict, job):
    job_type = job['job_type']
    job_description = job['description']

    try:
        plugin = plugin_dict[job_type]
    except KeyError:
        logging.error("no plugin found for job type '{0}'".format(job_type))
    else:
        return plugin.create_job(job_description)


if __name__ == "__main__":
    sys.exit(main())
